# regex

## Intro

### Паттерн  

Это шаблон поиска, может содержать обычные символы и метасимволы.  
В Python за работу с регулярками отвечает модуль re:  

```py
import re

ptn = re.compile(r"выражение", re.I);
```

### Флаги (модификаторы)  

Это способ настройки поиска.  

- re.I - игнорировать регистр симвода: A == a  
- re.L - учитывать настройки текущей локали  
- re.M - многострочный режим (для строк с символом \n, используются якоря ^ $)
- re.S - включить режим «dotall», при котором точка . может соответствовать символу перевода строки \n  
- re.X - игнорировать символы - пробел и перенос строки  
- re.A - привести в соответсвие, символы - \w, \W, \b, \B, \d, \D, \s, \S будут соответсвовать символам ASCII  

---  

## Методы re  

- s - проверяемая строка  
- ptn.split(s[, limit]) - делит строку на список строк по шаблону разделителя  
- ptn.search(s[, start, finish]) - проверяет, есть ли хоть одно совпадение (Match|None)  
- ptn.findall(s[, start, finish]) - список всех совпадений с шаблоном  
- ptn.match(s[, start, finish]) - поиск первого совпадения (Match|None)  
- ptn.fullmatch(s[, start, finish]) - проверка на полное совпадение (Match|None)  
- ptn.finditer(s[, start, finish]) - возвращает итератор с совпадениями  
- ptn.sub("что вставить", "исходная строка"[, limit]) - заменить в исходной строке, что вставить может быть регуляркой  
- ptn.subn() - как sub(), но возвращает не строку, а кортеж (новая строка, сколько было замен)  

- match.expand() - для реализации замен, аналог sub()  
- re.escape() - экранировать специальные символы, re.escape(r"[).*") -> \[\)\.\*  
- re.purge() - очистить кэш после обработки большого количества регулярок  

## Синтаксис

### Символы

- обычные символы трактуются как есть  
- метасимволы - это управляющие конструкции, изменяют алгоритм проверки строки  

Когда метасимволы  

```txt
. ^ $ * + ? [ ] ( ) { } \ |
```

нужно использовать как есть, то их приходится экранировать обратным слешем \  

Обратный слеш также используется для формирования управляющих воздействий, например:  

```txt
\d - любая цифра
\s - пробельный символ
```

### Метасимволы

```txt
. - любой символ
^ - начало строки - зависит от флагов M и S  
$ - конец строки - зависит от флагов M и S  
\b - начало слова (не буква, не цифра, не знак подчёркивания)  
\B - НЕ начало слова  
[] - возможный символ из множества
[^] - любой символ не из этого множества - [^0-9] - НЕ цифра  
[012] - возможный символ из множества
[-a-z0-9] - возможный символ из множества, первый - это просто -, остальные задают диапазоны
[А-ЯЁ] - возможный символ из множества, Ё указываем отдельно
| - логическое ИЛИ
\. - точка  
\d - любая цифра  
\D - НЕ цифра  
\w - любая буква, цифра и знак подчёркивания, если есть флаг A, то это - [a-zA-Z0-9_]  
\W - НЕ (буква, цифра или знак подчёркивания), если есть флаг A, то это - [^a-zA-Z0-9_]  
\s - любой пробельный символ, если есть флаг A, то это - [\t\n\r\f\v]  
\S - НЕ пробельный символ, если есть флаг A, то это - [^\t\n\r\f\v]  
```

### Квантификаторы

Проверка на повторяемость:

```txt
{n} - n раз
{n,} - n или более раз
{n,m} - от n до m раз
+ - один или более раз {1,}
* - ноль или более раз {0,}
? - ноль или один раз {0,1}
```

### Жадность квантификаторов

По умолчанию ищется самая длинная подстрока, соответствующая паттерну.
Если срузу после квантификатора поставить ?, то будет производиться поиск минимальной подстроки, соответствующей шаблону.

### Группы

Группа - значимая часть строки, способ обозначить подстрок(у/и) в исходной строке.  
Так можно получать только внутреннюю часть найденных по шаблону тегов html.  
Или наоборот из результатов поиска исключать лишние данные.  

```txt
() - скобки включают в себя необходимую часть шаблона
(()-()) - можно группировать отдельные части
( )-() - или делать несколько групп
(?: ) - такие скобки исключат из результатов поиска эту часть шаблона
(?= ) - положительный просмотр вперёд, исключить группу перед которой что-то и шаблон группы соответсвует
(?! ) - отрицательный просмотр вперёд, исключить группу перед которой что-то, но шаблон группы НЕ соответсвует
(?<= ) - положительный просмотр назад, исключить группу после которой что-то и шаблон группы соответсвует
(?<! ) - отрицательный просмотр назад, исключить группу после которой что-то, но шаблон группы НЕ соответсвует
\1 - обратная ссылка - можно в шаблоне делать ссылку на группу внутри этого же шаблона

(?#...) - комментарий внутри скобок игнорируется  
(?P<name>...) - можно выбирать значение группы по имени -  ptn.search(s).group("name")  
```

---  

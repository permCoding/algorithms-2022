# Алгоритмы сортировки  

[**Доска**](https://jamboard.google.com/d/1ezwMzRni3bc7YjJF4fdSoz9z7wQjmXyP10-HGqt7T8Y/edit?usp=sharing)  

---  

## ЛАБРАБ 01

**Сортировка вставками**  

*Задания:*  

> Разработать функцию сортировки списка вставками  
> Провести эксперимент - как растёт время сортировки при росте количества элементов n  
> В своём репозитории с помощью разметки markdown создать краткое описание вашей функции сортировки  
> В описание добавить таблицу с данными роста времени исполнения с помощью специальной разметки markdown
> 

---  

## ЛАБРАБ 02

**Сортировка выбором и пузырьковая**  

*Задания:*  

> Разработать функцию сортировки списка выбором  
> Взать себе две функции с Лекции: сортировка пузырьком и сортировка пузырьком улучшенная  
> Провести эксперимент - как растёт время сортировки при росте количества элементов n  
> Сравнить четыре сортировки: вставкой, выбором, пузырьком и пузырьком улучшенная  
> В своём репозитории с помощью разметки markdown создать краткое описание вашей функции сортировки выбором  
> В описание добавить сводную таблицу с данными роста времени исполнения четырёх перечисленных функций  
> 

---  

## Как собрать данные с нескольких функций сортировки на списках разной длины

Пример:  
> назначаем значение максимальной длины списка (max_count) для сортировки
> генерируем список случайных элементов этой длины
> запускаем цикл для изменения количества элементов в неотсортированном списке с шагом 1000
> на каждой итерации делаем срезы (lst1, lst2) из исходного неотсортированного списка
> длина этих срезов на каждой итерации увеличивается на 1000 - чтобы провести испытания на списках разной длины
> на каждой итерации по отдельности запускаем измерение продолжительности работы функций сортировки
> получаемые данные выводим на экран

Сама программа:  

```txt
import timeit 
import algo_sort as m


max_count = 10000
lst = m.get_lst(max_count)

for count in range(1000, max_count+1, 1000):
    
    lst1 = lst[:count+1]
    lst2 = lst[:count+1]

    start_time = timeit.default_timer() 
    m.sort_bubble(lst1)
    res1 = timeit.default_timer() - start_time
    
    start_time = timeit.default_timer() 
    m.sort_bubble_plus(lst2)
    res2 = timeit.default_timer() - start_time
    
    print(f"{count}\t{round(res1, 2)}\t{round(res2, 2)}")
```

Результаты её работы:  

```txt
1000    0.1     0.09
2000    0.38    0.36
3000    0.79    0.8
4000    1.41    1.42
5000    2.22    2.47
6000    3.43    3.49
7000    5.01    4.84
8000    6.11    6.21
9000    7.75    7.74
10000   10.01   9.9
```

---
